# export GCP_AUTH_KIND=serviceaccount
# export GCP_SERVICE_ACCOUNT_FILE=/home/filip/webserver1-283520-386230d8738c.json
# export GCP_SCOPES=https://www.googleapis.com/auth/compute,https://www.googleapis.com/auth/cloud-platform
# ansible-playbook cluster.yaml
---
- hosts: localhost
  vars:
    location: us-west1
    storage_instance:
      name: webserverstorage1
    project_id: webserver1-283520
    sql_instance:
      name: webserverdb7
      backend_type: SECOND_GEN
      database_version: POSTGRES_12
      region: us-west1
      tier: db-g1-small
      db_user: einvoice
      db_password: 12345
      db_name: einvoice
    cluster_name: my-cluster1
  tasks:
# kubernetes cluster
    - name: create a cluster
      gcp_container_cluster:
        name: '{{ cluster_name }}'
        initial_node_count: 1
        master_auth:
          username: cluster_admin
          password: my-secret-password
        location: '{{ location }}'
        project: webserver1-283520
        state: present
      register: cluster
    - name: setup kubect
      command: gcloud container clusters get-credentials '{{ cluster_name }}' --region us-west1 --project '{{ project_id }}'
    - name: create a node pool
      gcp_container_node_pool:
        name: my-pool
        initial_node_count: 1
        cluster: "{{ cluster }}"
        location: '{{ location }}'
        project: '{{ project_id }}'
        config:
          oauth_scopes: [
            'https://www.googleapis.com/auth/devstorage.read_only',
            'https://www.googleapis.com/auth/sqlservice.admin'
          ]
          machine_type: n1-standard-4
          disk_size_gb: 500
        state: present
        autoscaling:
          enabled: no
# bucket
    - name: create a bucket
      gcp_storage_bucket:
        name: '{{ storage_instance.name }}'
        project: '{{ project_id }}'
        state: present
# sql database
    - name: Create GCP CloudSQL instance
      gcp_sql_instance:
        name: '{{ sql_instance.name }}'
        backend_type: '{{ sql_instance.backend_type }}'
        database_version: '{{ sql_instance.database_version }}'
        settings:
          tier: '{{ sql_instance.tier }}'
        region: '{{ sql_instance.region }}'
        project: '{{ project_id }}'
        state: present
      register: instance
    - name: Create database
      ignore_errors: yes
      gcp_sql_database:
        name: einvoice
        charset: utf8
        instance: "{{ instance.name }}"
        project: '{{ project_id }}'
        state: present
    - name: create a user
      ignore_errors: yes
      gcp_sql_user:
        name: einvoice
        host: '{{ instance.ipAddresses[0].ipAddress }}'
        password: 12345
        instance: "{{ instance }}"
        project: '{{ project_id }}'
        state: present
# api server
    - service: name=docker state=started
    - name: Docker Login
      docker_login:
        registry: gcr.io/webserver1-283520/apiserver
        username: _json_key
        debug: true
        password: " {{ lookup('file', '/home/filip/mfsr/webserver1-283520-386230d8738c.json')}}"
    - name: Build apiserver and push it to a private repo
      docker_image:
        build:
          path: ../
          dockerfile: Dockerfile-apiserver
        name: gcr.io/webserver1-283520/apiserver
        tag: latest
        push: yes
        force: yes
        source: build
        state: present
    - name: create apiserver deployment
      k8s:
        state: present
        name: apiserver
        api_version: v1
        definition:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            labels:
              app: apiserver
            name: apiserver
            namespace: default
          spec:
            replicas: 1
            strategy:
              type: Recreate
            selector:
              matchLabels:
                app: apiserver
            template:
              metadata:
                labels:
                  app: apiserver
              spec:
                restartPolicy: Always
                containers:
                  - name: apiserver
                    image: gcr.io/webserver1-283520/apiserver:latest
                    imagePullPolicy: Always
                    env:
                      - name: SLOW_STORAGE_TYPE
                        value: local
                      - name: LOCAL_STORAGE_BASE_PATH
                        value: /tmp/einvoice
                      - name: DB_HOST
                        value: 127.0.0.1
                      - name: DB_PORT
                        value: "5432"
                      - name: DB_USER
                        value: '{{ sql_instance.db_user }}'
                      - name: DB_PASSWORD
                        value: '{{ sql_instance.db_password }}'
                      - name: DB_NAME
                        value: '{{ sql_instance.db_name }}'
                    ports:
                    - containerPort: 8080
                  - name: cloud-sql-proxy
                    image: gcr.io/cloudsql-docker/gce-proxy:1.17
                    command:
                      - "/cloud_sql_proxy"
                      - '-instances={{instance.connectionName}}=tcp:5432'
                    securityContext:
                      runAsNonRoot: true
    - name: create apiserver loadbalancer
      k8s:
        state: present
        name: apiserver-loadbalancer
        api_version: v1
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            labels:
              app: apiserver
            name: apiserver-loadbalancer
            namespace: default
          spec:
            externalTrafficPolicy: Cluster
            ports:
              - port: 80
                protocol: TCP
                targetPort: 8080
            selector:
              app: apiserver
            sessionAffinity: None
            type: LoadBalancer
      register: apiserver_service
    - name: waiting for apiserver loadbalancer ip
      command: bash -c 'external_ip="<pending>"; while [ $external_ip = "<pending>" ]; do result=$(kubectl get svc apiserver-loadbalancer | tail -n1); ip=($result); external_ip=${ip[3]}; [ $external_ip = "<pending>" ] && sleep 10; done; echo $external_ip;'
      register: result
    - set_fact: apiserver_loadbalancer_ip="{{ result.stdout_lines[0] }}"
    - debug:
        msg: '{{ apiserver_loadbalancer_ip }}'
# web-app
    - name: Build web-app and push it to a private repo
      docker_image:
        build:
          path: ../
          dockerfile: einvoice-web-app.Dockerfile
        name: gcr.io/webserver1-283520/web-app
        tag: latest
        push: yes
        force: yes
        source: build
        state: present
    - name: create web-app deployment
      k8s:
        state: present
        name: develop
        api_version: v1
        definition:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            labels:
              app: web-app
            name: web-app
            namespace: default
          spec:
            replicas: 1
            strategy:
              type: Recreate
            selector:
              matchLabels:
                app: web-app
            template:
              metadata:
                labels:
                  app: web-app
              spec:
                restartPolicy: Always
                containers:
                  - name: web-app
                    image: gcr.io/webserver1-283520/web-app:latest
                    imagePullPolicy: Always
                    env:
                      - name: API_SERVER_URL
                        value: 'http://{{ apiserver_loadbalancer_ip }}'
                    ports:
                    - containerPort: 8081
    - name: create web-app loadbalancer
      k8s:
        state: present
        name: web-app-loadbalancer
        api_version: v1
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            labels:
              app: web-app
            name: web-app-loadbalancer
            namespace: default
          spec:
            externalTrafficPolicy: Cluster
            ports:
            - port: 80
              protocol: TCP
              targetPort: 8081
            selector:
              app: web-app
            sessionAffinity: None
            type: LoadBalancer
      register: loadbalancer
    - debug:
        msg: '{{ loadbalancer }}'
    - name: waiting for web-app loadbalancer ip
      command: bash -c 'external_ip="<pending>"; while [ $external_ip = "<pending>" ]; do result=$(kubectl get svc web-app-loadbalancer | tail -n1); ip=($result); external_ip=${ip[3]}; [ $external_ip = "<pending>" ] && sleep 10; done; echo $external_ip;'
      register: webapp_loadbalancer_result
    - set_fact: webapp_loadbalancer_ip="{{ webapp_loadbalancer_result.stdout_lines[0] }}"
    - debug:
        msg: 'web-app-ip is {{ webapp_loadbalancer_ip }}'