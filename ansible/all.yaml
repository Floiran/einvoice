# export GCP_AUTH_KIND=serviceaccount
# export GCP_SERVICE_ACCOUNT_FILE=/home/filip/mfsr/webserver1-283520-386230d8738c.json
# export GCP_SCOPES=https://www.googleapis.com/auth/compute,https://www.googleapis.com/auth/cloud-platform
# ansible-playbook all.yaml
---
- hosts: localhost
  vars:
    location: us-west1
    storage_instance:
      name: webserverstorage1
    project_id: webserver1-283520
    sql_instance:
      name: webserverdb13
      backend_type: SECOND_GEN
      database_version: POSTGRES_12
      region: us-west1
      tier: db-g1-small
      db_user: einvoice
      db_password: 12345
      db_name: einvoice
    cluster_name: my-cluster1
    docker_password: " {{ lookup('file', '/home/filip/mfsr/webserver1-283520-386230d8738c.json')}}"
  tasks:
# kubernetes cluster
    - name: create a cluster
      gcp_container_cluster:
        name: '{{ cluster_name }}'
        initial_node_count: 1
        master_auth:
          username: cluster_admin
          password: my-secret-password
        location: '{{ location }}'
        project: webserver1-283520
        ip_allocation_policy:
          use_ip_aliases: yes
        state: present
      register: cluster
    - name: setup kubect
      command: gcloud container clusters get-credentials '{{ cluster_name }}' --region us-west1 --project '{{ project_id }}'
    - name: create a node pool
      gcp_container_node_pool:
        name: my-pool
        initial_node_count: 1
        cluster: "{{ cluster }}"
        location: '{{ location }}'
        project: '{{ project_id }}'
        config:
          oauth_scopes: [
            'https://www.googleapis.com/auth/devstorage.read_write',
            'https://www.googleapis.com/auth/sqlservice.admin'
          ]
          machine_type: n1-standard-4
          disk_size_gb: 500
        state: present
        autoscaling:
          enabled: no
# bucket
    - name: create a bucket
      gcp_storage_bucket:
        name: '{{ storage_instance.name }}'
        project: '{{ project_id }}'
        state: present
# sql database
    - name: Create GCP CloudSQL instance
      gcp_sql_instance:
        name: '{{ sql_instance.name }}'
        backend_type: '{{ sql_instance.backend_type }}'
        database_version: '{{ sql_instance.database_version }}'
        settings:
          tier: '{{ sql_instance.tier }}'
        region: '{{ sql_instance.region }}'
        project: '{{ project_id }}'
        state: present
      register: instance
    - name: Create database
      ignore_errors: yes
      gcp_sql_database:
        name: einvoice
        charset: utf8
        instance: "{{ instance.name }}"
        project: '{{ project_id }}'
        state: present
    - name: create a user
      ignore_errors: yes
      gcp_sql_user:
        name: einvoice
        host: '{{ instance.ipAddresses[0].ipAddress }}'
        password: 12345
        instance: "{{ instance }}"
        project: '{{ project_id }}'
        state: present
# api server
    - service: name=docker state=started
    - name: Docker Login
      docker_login:
        registry: gcr.io/webserver1-283520/apiserver
        username: _json_key
        debug: true
        password: '{{ docker_password }}'
    - name: Build apiserver and push it to a private repo
      docker_image:
        build:
          path: ../
          dockerfile: Dockerfile-apiserver
        name: gcr.io/webserver1-283520/apiserver
        tag: latest
        push: yes
        force: yes
        source: build
        state: present
    - name: create apiserver deployment
      k8s:
        state: present
        name: apiserver
        api_version: v1
        definition:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            labels:
              app: apiserver
            name: apiserver
            namespace: default
          spec:
            replicas: 1
            strategy:
              type: Recreate
            selector:
              matchLabels:
                app: apiserver
            template:
              metadata:
                labels:
                  app: apiserver
              spec:
                restartPolicy: Always
                containers:
                  - name: apiserver
                    image: gcr.io/webserver1-283520/apiserver:latest
                    imagePullPolicy: Always
                    env:
                      - name: SLOW_STORAGE_TYPE
                        value: gcs
                      - name: GCS_BUCKET
                        value: webserverstorage1
                      - name: DB_HOST
                        value: 127.0.0.1
                      - name: DB_PORT
                        value: "5432"
                      - name: DB_USER
                        value: '{{ sql_instance.db_user }}'
                      - name: DB_PASSWORD
                        value: '{{ sql_instance.db_password }}'
                      - name: DB_NAME
                        value: '{{ sql_instance.db_name }}'
                    ports:
                    - containerPort: 8080
                  - name: cloud-sql-proxy
                    image: gcr.io/cloudsql-docker/gce-proxy:1.17
                    command:
                      - "/cloud_sql_proxy"
                      - '-instances={{instance.connectionName}}=tcp:5432'
                    securityContext:
                      runAsNonRoot: true
    - name: create apiserver loadbalancer
      k8s:
        state: present
        name: apiserver-loadbalancer
        api_version: v1
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            labels:
              app: apiserver
            name: apiserver-loadbalancer
            namespace: default
          spec:
            ports:
              - port: 80
                protocol: TCP
                targetPort: 8080
            selector:
              app: apiserver
            type: ClusterIP
      register: apiserver_service
# redis
    - name: create redis instance
      gcp_redis_instance:
        name: instance1
        tier: STANDARD_HA
        memory_size_gb: 1
        region: '{{ location }}'
        redis_version: REDIS_3_2
        display_name: Auth db
        reserved_ip_range: 192.168.0.0/29
        project: '{{ project_id }}'
        state: present
      register: redis
# auth proxy
    - name: Build authproxy and push it to a private repo
      docker_image:
        build:
          path: ../
          dockerfile: Dockerfile-authproxy
        name: gcr.io/webserver1-283520/authproxy
        tag: latest
        push: yes
        force: yes
        source: build
        state: present
    - name: create authproxy deployment
      k8s:
        state: present
        name: authproxy
        api_version: v1
        definition:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            labels:
              app: authproxy
            name: authproxy
            namespace: default
          spec:
            replicas: 1
            strategy:
              type: Recreate
            selector:
              matchLabels:
                app: authproxy
            template:
              metadata:
                labels:
                  app: authproxy
              spec:
                restartPolicy: Always
                containers:
                  - name: authproxy
                    image: gcr.io/webserver1-283520/authproxy:latest
                    imagePullPolicy: Always
                    env:
                      - name: APISERVER_URL
                        value: 'http://{{apiserver_service.result.spec.clusterIP}}:80'
                      - name: REDIS_URL
                        value: '{{redis.host}}:{{redis.port}}'
                    ports:
                      - containerPort: 8082
    - name: create authproxy loadbalancer
      k8s:
        state: present
        name: authproxy-loadbalancer
        api_version: v1
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            labels:
              app: authproxy
            name: authproxy-loadbalancer
            namespace: default
          spec:
            externalTrafficPolicy: Cluster
            ports:
              - port: 80
                protocol: TCP
                targetPort: 8082
            selector:
              app: authproxy
            sessionAffinity: None
            type: LoadBalancer
      register: authproxy_service
    - name: waiting for authproxy loadbalancer ip
      command: bash -c 'external_ip="<pending>"; while [ $external_ip = "<pending>" ]; do result=$(kubectl get svc authproxy-loadbalancer | tail -n1); ip=($result); external_ip=${ip[3]}; [ $external_ip = "<pending>" ] && sleep 5; done; echo $external_ip;'
      register: result
    - set_fact: authproxy_loadbalancer_ip="{{ result.stdout_lines[0] }}"
    - debug:
        msg: 'proxy ip: {{ authproxy_loadbalancer_ip }}'
# web-app
    - name: Build web-app and push it to a private repo
      docker_image:
        build:
          path: ../
          dockerfile: Dockerfile-einvoice-web-app
        name: gcr.io/webserver1-283520/web-app
        tag: latest
        push: yes
        force: yes
        source: build
        state: present
    - name: create web-app deployment
      k8s:
        state: present
        name: develop
        api_version: v1
        definition:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            labels:
              app: web-app
            name: web-app
            namespace: default
          spec:
            replicas: 1
            strategy:
              type: Recreate
            selector:
              matchLabels:
                app: web-app
            template:
              metadata:
                labels:
                  app: web-app
              spec:
                restartPolicy: Always
                containers:
                  - name: web-app
                    image: gcr.io/webserver1-283520/web-app:latest
                    imagePullPolicy: Always
                    env:
                      - name: API_SERVER_URL
                        value: 'http://{{ authproxy_loadbalancer_ip }}'
                    ports:
                    - containerPort: 8081
    - name: create web-app loadbalancer
      k8s:
        state: present
        name: web-app-loadbalancer
        api_version: v1
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            labels:
              app: web-app
            name: web-app-loadbalancer
            namespace: default
          spec:
            externalTrafficPolicy: Cluster
            ports:
            - port: 80
              protocol: TCP
              targetPort: 8081
            selector:
              app: web-app
            sessionAffinity: None
            type: LoadBalancer
      register: loadbalancer
    - name: waiting for web-app loadbalancer ip
      command: bash -c 'external_ip="<pending>"; while [ $external_ip = "<pending>" ]; do result=$(kubectl get svc web-app-loadbalancer | tail -n1); ip=($result); external_ip=${ip[3]}; [ $external_ip = "<pending>" ] && sleep 5; done; echo $external_ip;'
      register: webapp_loadbalancer_result
    - set_fact: webapp_loadbalancer_ip="{{ webapp_loadbalancer_result.stdout_lines[0] }}"
    - debug:
        msg: 'web-app ip: {{ webapp_loadbalancer_ip }}'